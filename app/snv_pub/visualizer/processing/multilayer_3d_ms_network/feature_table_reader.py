

import pandas as pd
import numpy
import sys

class mass_feature:
    def __init__(self):
            self.global_accession =""
            self.feature_id = ""
            self.dic_area ={}
            self.value_to_show =0
            self.stat_val = 1.0


def create_mass_feature(**kwargs):
    mf = {
        'global_accession': '',
        'feature_id': '',
        'dic_area': {},
        'value_to_show': 0,
        'stat_val': 1.0
    }

    for k, v in kwargs.items():
        if k in mf:
            mf[k] = v

    return mf


##########
# this function is to read table containing quantative analysis result typicaly generated by jupyter notebook "data analysis"
def feature_table_reader_quant_res(filename) :
    print("feature_table_reader_quant_res started")

    tsv_data = pd.read_csv(filename, delimiter='\t', index_col=None)

    f_stat_val = 0

    # first scan file and find header corresponds to impoartant values
    for colname in tsv_data.columns:
        if colname in ["GLOBAL_ACCESSION", "global_accession", "global accession"]:
            colname_global_accession = colname
        if colname in ["RATIO_VALID", "ratio_valid", "RATIO"]:
            colname_ratio = colname
        if colname in ["T_TEST_PVAL", "t_test_pval", "STAT_VAL"]:
            f_stat_val = 1
            colname_pval = colname

    ## check if the file contain correct info
    if len(colname_global_accession) == 0 or len(colname_ratio)  == 0:
        print("ERROR from read_feature_quant_res files : column name is not correct.")
        sys.exit()


    dic_mf = {}
    count = 0
    # iterate rows and get corresponding info
    for key, row in tsv_data.iterrows():
        #    '#ClusterIdx' is the header
        # mf = mass_feature()  # TODO: Use dictionary
        mf = create_mass_feature()
        mf['stat_val'] = 1.0
        global_accession = row[colname_global_accession]
        mf['global_accession'] = global_accession

        mf['value_to_show'] = float(row[colname_ratio])
        if numpy.isnan(row[colname_ratio]):
            mf['value_to_show'] = 1.0

        # if statistical value is present in feature table.
        if f_stat_val == 1:
            if (  float(row[colname_pval]) > 0 ):
                mf['stat_val'] = float(row[colname_pval])

        # if statitical value is Not available
        if f_stat_val == 0:
            mf['stat_val'] = 0.0

        if type(mf['stat_val']) == "float":
            print("ERROR from read_feature_quant_res files : pval is not float.")
            sys.exit()

        dic_mf[global_accession] = mf

        count = count + 1

    print("feature_table_reader_quant_res FINISHED")

    return dic_mf



####
# this function is to read raw mzmine feature table to read raw content.
#   comparison, data processing is done later.

def feature_table_reader_mzmine(filename) :

    df = pd.read_csv(filename)



    # get sample names
    print(df.columns.values)


    print("num of sampels:" , len(df.columns.values ) -3)

    # get sample names
    ###  you have to be carefull about the number of columns
    l_sample_names = df.columns.values [3: len(df.columns.values ) - 1 ]
    print(l_sample_names)
    dic_area_sum = {}

    for n in range(0, len(l_sample_names)):
        dic_area_sum[l_sample_names[n]] = df[l_sample_names[n]].sum()

    print(dic_area_sum)



    dic_mf = {}

    for key, row in df.iterrows():
        mf = mass_feature()
        #print int(row['row ID'])
        mf['feature_id'] = str(int(row['row ID']))
        for n in range(0, len(l_sample_names)):
            #print l_sample_names[n], row[l_sample_names[n]]
            mf['dic_area'][l_sample_names[n]] = row[l_sample_names[n]]
        dic_mf[str(int(row['row ID']))] = mf

    print(dic_mf["7"].dic_area)

    # NORMALIZE
    for k, v in dic_mf.items():
        # print v.feature_id
        # print v.dic_area

        for name, area in v['dic_area'].items():
            # print name
            v['dic_area'][name] = area / dic_area_sum[name] * 1E5

    return dic_mf


#  calue is cals as X/Y     [0] is X and [1] is Y
def get_ratio( dic_mf_in , l_comparison_pair_x_y = [ "x" , "y"] ) :

    l_value_to_show =[]
    for k, o_mf in dic_mf_in.items():
        value_calc = o_mf['dic_area'][l_comparison_pair_x_y[0]] / o_mf['dic_area'][l_comparison_pair_x_y[1]]
        o_mf['value_to_show'] = value_calc

        if   o_mf['dic_area'][l_comparison_pair_x_y[0]] != 0   and o_mf['dic_area'][l_comparison_pair_x_y[1]] != 0  :

            l_value_to_show.append( value_calc )

    # if X or Y is 0 value,
    # if X > 0 and Y = 0, put the hiest value observed + 10 %.
    for k, o_mf in dic_mf_in.items():
        # if either X or Y is 0,
        if   o_mf['dic_area'][l_comparison_pair_x_y[0]] == 0   and o_mf['dic_area'][l_comparison_pair_x_y[1]] != 0  :
            o_mf['value_to_show'] = 0
        if o_mf['dic_area'][l_comparison_pair_x_y[0]] != 0  and  o_mf['dic_area'][l_comparison_pair_x_y[1]] == 0 :
            o_mf['value_to_show'] = max(l_value_to_show) + max(l_value_to_show) * 0.1

