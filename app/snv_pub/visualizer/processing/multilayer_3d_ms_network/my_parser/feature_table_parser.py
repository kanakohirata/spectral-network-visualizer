from logging import getLogger
import numpy as np
import pandas as pd
from .. import feature_table_reader

logger = getLogger(__name__)


class mass_feature:
    def __init__(self):
        self.global_accession = ""
        self.feature_id = ""
        self.dic_area = {}
        self.value_to_show = 0
        self.stat_val = 1.0


def create_mass_feature(**kwargs):
    mf = {
        'global_accession': '',
        'feature_id': '',
        'dic_area': {},
        'value_to_show': 0,
        'stat_val': 1.0
    }

    for k, v in kwargs.items():
        if k in mf:
            mf[k] = v

    return mf


##########
# this function is to read table containing quantitative analysis result typically generated by jupyter notebook "data analysis"
def read_quantitative_table(path):
    logger.debug('Start read_quantitative_table()')

    df = pd.read_csv(path, delimiter='\t', index_col=None)

    flag_stat_val = 0

    colname_global_accession = ''
    colname_ratio = ''
    colname_pval = ''
    flag_stat_val = False
    # first scan file and find header corresponds to important values
    for colname in df.columns:
        if colname in ['GLOBAL_ACCESSION', 'global_accession', 'global accession']:
            colname_global_accession = colname
        if colname in ['RATIO_VALID', 'ratio_valid', 'RATIO']:
            colname_ratio = colname
        if colname in ['T_TEST_PVAL', 't_test_pval', 'STAT_VAL']:
            flag_stat_val = True
            colname_pval = colname

    # check if the file contain correct info
    if (not colname_global_accession) or (not colname_ratio):
        raise ValueError("ERROR from read_quantitative_table files : column name is not correct.\n"
                         "Required: 'global_accession', 'ratio_valid'\n"
                         "Accepted: 't_test_pval'")

    df.rename(inplace=True,
              columns={colname_global_accession: 'global_accession', colname_ratio: 'value_to_show'})
    df['value_to_show'] = df['value_to_show'].astype(float)
    df['value_to_show'] = df['value_to_show'].fillna(1.0)

    if flag_stat_val:
        df.rename(inplace=True, columns={colname_pval: 'stat_val'})
        df['stat_val'] = df['stat_val'].astype(float)
        df['stat_val'] = df['stat_val'].fillna(1.0)
    else:
        df['stat_val'] = 1

    df['feature_id'] = ''
    df['dic_area'] = [{}, ] * len(df)
    df = df[['global_accession', 'feature_id', 'dic_area', 'value_to_show', 'stat_val']]
    df.set_index('global_accession', inplace=True, drop=False)

    dic_mf = df.to_dict(orient='index')
    logger.debug("read_quantitative_table() FINISHED")

    return dic_mf


####
# this function is to read raw mzmine feature table to read raw content.
#   comparison, data processing is done later.
# TODO: Check mzmine feature table.
def read_mzmine_table(path):
    logger.debug('Start read_mzmine_table()')
    df = pd.read_csv(path)

    # get sample names
    logger.debug(f'num of samples: {len(df.columns.values) - 3}')

    # get sample names
    # you have to be careful about the number of columns
    l_sample_names = df.columns.values[3: len(df.columns.values) - 1]
    logger.debug(f'sample names: {l_sample_names}')
    dic_area_sum = {}

    for sample_name in l_sample_names:
        dic_area_sum[sample_name] = df[sample_name].sum()

    dic_mf = {}

    for key, row in df.iterrows():
        mf = create_mass_feature()
        # print int(row['row ID'])
        mf['feature_id'] = str(row['row ID'])
        for n in range(0, len(l_sample_names)):
            # print l_sample_names[n], row[l_sample_names[n]]
            mf['dic_area'][l_sample_names[n]] = row[l_sample_names[n]]
        dic_mf[str(row['row ID'])] = mf

    print(dic_mf['7']['dic_area'])

    # NORMALIZE
    for k, v in dic_mf.items():
        # print v.feature_id
        # print v.dic_area

        for name, area in v['dic_area'].items():
            # print name
            v['dic_area'][name] = area / dic_area_sum[name] * 1E5

    return dic_mf


#  calue is cals as X/Y     [0] is X and [1] is Y
# TODO: Check l_comparison_pair_x_y
def get_ratio(dic_mf_in, l_comparison_pair_x_y=None):
    if len(l_comparison_pair_x_y) != 2:
        raise IndexError()

    l_value_to_show = []
    for k, o_mf in dic_mf_in.items():
        value_calc = o_mf['dic_area'][l_comparison_pair_x_y[0]] / o_mf['dic_area'][l_comparison_pair_x_y[1]]
        o_mf['value_to_show'] = value_calc

        if o_mf['dic_area'][l_comparison_pair_x_y[0]] != 0 and o_mf['dic_area'][l_comparison_pair_x_y[1]] != 0:
            l_value_to_show.append(value_calc)

    # if X or Y is 0 value,
    # if X > 0 and Y = 0, put the highest value observed + 10 %.
    for k, o_mf in dic_mf_in.items():
        # if either X or Y is 0,
        if o_mf['dic_area'][l_comparison_pair_x_y[0]] == 0 and o_mf['dic_area'][l_comparison_pair_x_y[1]] != 0:
            o_mf['value_to_show'] = 0
        if o_mf['dic_area'][l_comparison_pair_x_y[0]] != 0 and o_mf['dic_area'][l_comparison_pair_x_y[1]] == 0:
            o_mf['value_to_show'] = max(l_value_to_show) + max(l_value_to_show) * 0.1


def read_feature_table(config_o):
    # ratio_x_name = inifile.get("quant","ratio_x_name")
    # ratio_y_name = inifile.get("quant","ratio_y_name")

    feature_table_mode = 1

    # key is global accession  balue is dictionary "mf"     mf.global_accession  mf.value_to_show   mf.stat_val
    dic_global_accession_vs_mass_feature = {}

    # if feature table is not present.
    if len(config_o["filename_feature_table"]) < 3:
        logger.debug(f"no feature table specified in config {config_o['filename_feature_table']}")

        feature_table_mode = -1

    # if feature table is not present.
    if feature_table_mode == -1:
        logger.debug("no feature table provided")
        dic_global_accession_vs_mass_feature = {}

    elif feature_table_mode == 0:
        dic_global_accession_vs_mass_feature = read_mzmine_table(config_o["filename_feature_table"])
        get_ratio(dic_global_accession_vs_mass_feature, [config_o["ratio_x_name"], config_o["ratio_y_name"]])

    elif feature_table_mode == 1:
        # node dic 's key is global accession now. ( title|sourcefile)
        logger.debug("no feature table mode == 1")
        dic_global_accession_vs_mass_feature = read_quantitative_table(config_o["filename_feature_table"])

    str_o = "feature===\n"
    for k, v in dic_global_accession_vs_mass_feature.items():
        str_o = str_o + str(k) + "\t" + str(v['value_to_show']) + "\n"

    """
    for k,v in dic_global_accession_vs_mass_feature.items():
        print(k,v.value_to_show, v.stat_val)
    """

    return dic_global_accession_vs_mass_feature
